## 设计模式 ：
1.设计模式的概述

	设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。
    设计模式不是一种方法和技术，而是一种思想

2.设计模式的几个要素

	名字 必须有一个简单，有意义的名字
	
3.设计原则（六大原则）

	单一职责原则
	开闭原则
	里氏替换原则
	依赖注入原则
	接口分离原则
	迪米特原则

4.设计模式的分类（三种分类）

	创建型模式
		抽象工厂模式(Abstract Factory)
		建造者模式(Builder)
		工厂方法模式(Factory Method)
		原型模式(Prototype)
		单例模式(Singleton) 
		
	结构型模式
		适配器模式(Adapter)
		桥接模式(Bridge)
		组合模式(Composite)
		装饰模式(Decorator)
		外观模式(Facade)
		享元模式(Flyweight)
		代理模式(Proxy)
		
	行为型模式
		职责链模式(Chain of Responsibility)
		命令模式(Command)
		解释器模式(Interpreter)
		迭代器模式(Iterator)
		中介者模式(Mediator)
		备忘录模式(Memento)
		观察者模式(Observer)
		状态模式(State)
		策略模式(Strategy)
		模板方法模式(Template Method)
		访问者模式(Visitor)
5.单例设计模式

	（1）单例模式概述
         单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例
	（2）单例模式的特点：
		1.单例类只能有一个实例
		2.单例类必须自己创建自己的唯一实例
		3.单例类必须给所有其他对象提供这一实例
	（3）单例模式的关键有两点：
		1.构造方法为私有，这样外界就不能随意调用。
		2.get的方法为静态，由类直接调用
	（4）单例模式的三种写法：
	 	1.懒汉式单例:面试推荐写这种，因为面试官就像考试线程安全问题
		2.饿汉式单例：开发建议写，安全
		3.双重锁的形式

6.原型模式

	ICloneable.java			简历实体
	Number.java				电话实体
	TestICloneable.java		对象之间的复制
	TestICloneable2.java	浅复制
	TestICloneable3.java	深复制
	(1)原型模式概述
	字面意思指原来的类型或模型。在原型模式中我们可以利用过一个原型对象来指明我们所要创建对象的类型，然后通过复制这个对象的方法来获得与该对象一模一样的对象实例。这就是原型模式的目的。
	(2)原型模式优点：
		允许动态增加或减少产品类
	(3)原型模式缺点：
		每个要使用原型模式的类都必须实现Cloneable接口，添加clone方法
	(4)原型模式分类
		浅克隆：
			浅克隆就是值赋值Java对象中基本数据类型，而引用数据类型不会赋值
		深克隆：
			深克隆就是复制了基本数据类型又复制引用类型。
	
	体会 TestICloneable、TestICloneable2、TestICloneable3三者之间的区别。
	
7.工厂模式

	（1）工厂模式概述
         工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式

	（2）工厂分类：
		简单工厂（Simple Factory） 
			一个抽象产品类，可以派生出多个具体产品类。一个具体的工厂类可创建多个具体的产品类
			
			优点：
				客户端不需要负责对象创建，从而明确各个类的职责
			缺点：
				如果有新的对象添加，就要需改工厂类，不利于后期的维护。
				
				
		工厂方法（Factory Method） 
			一个抽象产品类，可以派生出多个具体的产品类。一个抽象工厂类，可以派生出多个具体的工厂类，每个具体的工厂类只能创建一个具体的产品类的实例
			
			优点：
				客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性

			缺点：
				需要额外的编写代码，增加了工作量
			
			
		抽象工厂（Abstract Factory） 
			多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例。

		
		水果、  蔬菜								         抽象工厂类
		
	北方水果    南方水果  北方蔬菜   南方蔬菜		北方产品工厂          南方产品工厂
	
	
	
8.代理模式

	代理模式分类：
		静态代理：需要定义接口或父类，被代理对象需要与代理对象实现同样的接口或者继承相同父类。
			（1）静态代理总结:
				1.可以做到在不修改目标对象的功能前提下,对目标功能扩展.
				2.缺点:
				
				因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.
				
				如何解决静态代理中的缺点呢?可以使用动态代理方式
			
		动态代理(JDK动态代理、CGLIB动态代理)
			JDK动态代理：必须实现一个或多个接口，如果想代理没有实现接口的类可以使用CGLIB代理。
			动态代理有以下特点:
				1.代理对象,不需要实现接口
				2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
				3.动态代理也叫做:JDK代理,接口代理
			总结：代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理
			
			
			CGLIB代理：又叫子类代理，在内存中构建一个子类对象从而实现对象目标对象功能的扩展。
				
				CGLIB代理需要引入cglib.jar文件